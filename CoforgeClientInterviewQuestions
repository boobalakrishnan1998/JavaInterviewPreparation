Write a Java program to filter list of persons with specific last name using Streams and Lambadas.

load balancer purpose . huge amount of request from ui/user and then how to handle it?

If we have monolithic application and then how many microservices we can write.

 

If Budget is less then what will be your approach related for Microservices.

int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};

1.Main Features of Java 8.

2.How many design patterns do you know. Explain them

3.Tell me about Composite design pattern.

4.Docker and Kubernetes hands on experience ? (Explain there working)

5.Which cloud technology worked on ?

6.Write a Java program to filter list of persons with specific last name using Streams and Lambadas.

7.You are given a file named nums.txt that contains a list of integers, one per line. Write a Java function that reads the integers from the file, an integer target from the user, and returns an array of two distinct indices such that the corresponding elements add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Contents of "nums.txt":

2

7

11

15

User Input: target = 9 Output: [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)

 

8.Read the string from the file and check if the string is palindrome also write JUnit for palindrome and write full working Junit.

A man, a plan, a canal – Panama
AmanaplanacanalPanama



"Was it a car or a cat I saw?'

AAABBB

ABCCBA

aaBBAA

aaBBAA 

ABDBDAA 

AABbBBCC


Output:  AAABBB - a palindrom, A man, a plan, a canal – Panama,

"Was it a car or a cat I saw?”

9.Load balancer purpose . huge amount of request from Ui/user and then how to handle it?

10.If we have monolithic application and then how many microservices we can write.

11.If Budget is less, than what will be your approach related for Microservices.

12.You're given a 3*3 matrix

Find out its diagonal sum

Find out minimum and maximum number from its diagonal

Rotate the matrix by 90 degrees

13.Read an integer from a file and find out all the prime till that number.

14.Write a Java function that reads a text file, where each line of the file contains a string. For each line, reverse the words in the string while maintaining the order of the words. You can assume that each line does not contain leading or trailing spaces and that there is exactly one space between each pair of words. After reversing the words in each line, print the modified lines.

 

 

input:

Hello World

Sabre the best

Java programming is fun

output:

olleH dlroW

erbaS eht tseb

avaJ gnimmargorp si nuf



public class SampleTest {

    public static void main(String[] args) {
                          // 0   1  2
        int[][] matrix = {{1, 2, 2},
                          {4, 5, 6},
                          {7, 8, 9}};

        /*0,2
                 1,1
                         2,0*/
        int sum=0;
        int sum1=0;
        int len=matrix.length;
        for (int i = 0; i < len; i++) {
                    sum=sum+matrix[i][i];
                    sum1=sum1+matrix[i][len-i-1];
        }
    }
}

There are several ways to handle a large number of user requests per second in Java at the application logic level. Some of the most common methods include:

Caching: Caching is a technique where frequently accessed data is stored in memory so that it can be quickly retrieved without having to go through the entire process of fetching the data from a database or other storage system.

Asynchronous Processing: Asynchronous processing allows your application to handle requests concurrently, rather than sequentially. This can be achieved using threads, or using a message queue.

Load Balancing: Load balancing is a technique that distributes incoming requests across multiple servers to ensure that no single server is overwhelmed with too many requests.

Scaling horizontally: Scaling horizontally means adding more servers to your application to handle more requests.

Horizontal partitioning: Horizontal partitioning is a technique where your data is split across multiple servers to allow for more efficient data retrieval.

Circuit Breaker: A circuit breaker is a design pattern that can prevent a cascading failure in a distributed system by breaking the circuit when a service becomes unresponsive.

Multi-threading: Multi-threading allows you to split a single process into multiple threads, allowing for more efficient processing.

Optimizing database queries: Optimizing database queries can help to reduce the number of requests required to retrieve data from a database.


-------------

If Budget is less then what will be your approach related for Microservices.

Prioritize Functionality: Instead of trying to build a comprehensive suite of microservices from the start, focus on delivering core functionalities first. This approach helps you create a functional foundation upon which you can iteratively add more services over time as your budget allows.

Use Open Source Technologies: Leverage open-source tools, frameworks, and libraries to reduce development costs. There are many established open-source solutions available for building and managing microservices, including service discovery (like Consul), API gateways (like Kong), and monitoring (like Prometheus).
 Examples include Kubernetes for orchestration, Docker for containerization, and Spring Boot for building Java-based microservices.

Cloud Services: Consider utilizing cloud services like AWS, Azure, or Google Cloud. These platforms offer pay-as-you-go models, which can help you manage costs effectively. They also provide tools and services that can streamline the development, deployment, and scaling of microservices.
Containerization and Orchestration: Embrace containerization (e.g., Docker) and orchestration (e.g., Kubernetes). These technologies simplify deployment and management of microservices by providing consistency across different environments and enabling efficient resource utilization.
Automated Testing and Deployment: Implement automated testing and deployment pipelines to reduce manual effort and ensure consistent quality. This can help catch issues early and streamline the release process.Automated Testing and Deployment: Implement automated testing and deployment pipelines to reduce manual effort and ensure consistent quality. This can help catch issues early and streamline the release process.
